Jinja2 Statements
=================

{% ... %} for Statements

{{ ... }} for Expressions to print to the template output

{# ... #} for Comments not included in the template output

Variable:
=========

{{ foo.bar }}  
{{ foo['bar'] }}

Filters:
========

Variables can be modified by filters. Filters are separated from the variable by a pipe symbol (|) and 
may have optional arguments in parentheses. Multiple filters can be chained. The output of one filter is applied to the next.

For example, {{ name|striptags|title }} will remove all HTML Tags from variable name and title-case the output (title(striptags(name))).

Filters that accept arguments have parentheses around the arguments, just like a function call. 
For example: {{ listx|join(', ') }} will join a list with commas (str.join(', ', listx)).

Test:

{% if loop.index is divisibleby 3 %}
{% if loop.index is divisibleby(3) %}   

divisible is a built-in tests

List of Builtin Tests
=====================

boolean(), even(), in(), mapping(), sequence(), callable(), false(), integer(), ne(), string(),
defined(), filter(), iterable(), none(), test(), divisibleby(), float(), le(), number(),
true(), eq(), ge(), lower(), odd(), undefined(), escaped(), gt(), lt(), sameas(), upper()

Whitespace Control:
===================

If an application configures Jinja to trim_blocks, the first newline after a template tag is removed automatically (like in PHP). 
The lstrip_blocks option can also be set to strip tabs and spaces from the beginning of a line to the start of a block. 
(Nothing will be stripped if there are other characters before the start of the block.)

With both trim_blocks and lstrip_blocks enabled, you can put block tags on their own lines, and the entire block line will be 
removed when rendered, preserving the whitespace of the contents. For example, without the trim_blocks and lstrip_blocks options, 
this template:

You can manually disable the lstrip_blocks behavior by putting a plus sign (+) at the start of a block:

<div>
        {%+ if something %}yay{% endif %}
</div>

Similarly, you can manually disable the trim_blocks behavior by putting a plus sign (+) at the end of a block:

<div>
    {% if something +%}
        yay
    {% endif %}
</div>

You can also strip whitespace in templates by hand. If you add a minus sign (-) to the start or end of a block (e.g. a For tag), a comment, or a variable expression, the whitespaces before or after that block will be removed:

{% for item in seq -%}
    {{ item }}
{%- endfor %}

Escaping
========

It is sometimes desirable – even necessary – to have Jinja ignore parts it would otherwise handle as variables or blocks. For example, if, with the default syntax, you want to use {{ as a raw string in a template and not start a variable, you have to use a trick.

The easiest way to output a literal variable delimiter ({{) is by using a variable expression:

{{ '{{' }}

For bigger sections, it makes sense to mark a block raw. For example, to include example 
Jinja syntax in a template, you can use this snippet:

{% raw %}
    <ul>
    {% for item in seq %}
        <li>{{ item }}</li>
    {% endfor %}
    </ul>
{% endraw %}

Base Template
=============

This template, which we’ll call base.html, defines a simple HTML skeleton document that you might
 use for a simple two-column page. It’s the job of “child” templates to fill the empty blocks with content:

<!DOCTYPE html>
<html lang="en">
<head>
    {% block head %}
    <link rel="stylesheet" href="style.css" />
    <title>{% block title %}{% endblock %} - My Webpage</title>
    {% endblock %}
</head>
<body>
    <div id="content">{% block content %}{% endblock %}</div>
    <div id="footer">
        {% block footer %}
        &copy; Copyright 2008 by <a href="http://domain.invalid/">you</a>.
        {% endblock %}
    </div>
</body>
</html>

Child Template
==============

A child template might look like this:

{% extends "base.html" %}
{% block title %}Index{% endblock %}
{% block head %}
    {{ super() }}
    <style type="text/css">
        .important { color: #336699; }
    </style>
{% endblock %}
{% block content %}
    <h1>Index</h1>
    <p class="important">
      Welcome to my awesome homepage.
    </p>
{% endblock %}

Super Blocks
============

It’s possible to render the contents of the parent block by calling super(). This gives back the results of the parent block:

{% block sidebar %}
    <h3>Table Of Contents</h3>
    ...
    {{ super() }}
{% endblock %}

Nesting extends
===============

In the case of multiple levels of {% extends %}, super references may be chained (as in super.super()) to skip levels in the inheritance tree.

For example:

# parent.tmpl
body: {% block body %}Hi from parent.{% endblock %}

# child.tmpl
{% extends "parent.tmpl" %}
{% block body %}Hi from child. {{ super() }}{% endblock %}

# grandchild1.tmpl
{% extends "child.tmpl" %}
{% block body %}Hi from grandchild1.{% endblock %}

# grandchild2.tmpl
{% extends "child.tmpl" %}
{% block body %}Hi from grandchild2. {{ super.super() }} {% endblock %}

Rendering child.tmpl will give body: Hi from child. Hi from parent.

Rendering grandchild1.tmpl will give body: Hi from grandchild1.

Rendering grandchild2.tmpl will give body: Hi from grandchild2. Hi from parent.

Named Block End-Tags
====================

Jinja allows you to put the name of the block after the end tag for better readability:

{% block sidebar %}
    {% block inner_sidebar %}
        ...
    {% endblock inner_sidebar %}
{% endblock sidebar %}

However, the name after the endblock word must match the block name.

Block Nesting and Scope
=======================

Blocks can be nested for more complex layouts. However, per default blocks may not access variables from outer scopes:

{% for item in seq %}
    <li>{% block loop_item %}{{ item }}{% endblock %}</li>
{% endfor %}

This example would output empty <li> items because item is unavailable inside the block. The reason for this is that if the block is replaced by a child template, a variable would appear that was not defined in the block or passed to the context.

Starting with Jinja 2.2, you can explicitly specify that variables are available in a block by setting the block to “scoped” by adding the scoped modifier to a block declaration:

{% for item in seq %}
    <li>{% block loop_item scoped %}{{ item }}{% endblock %}</li>
{% endfor %}

When overriding a block, the scoped modifier does not have to be provided.

Required Blocks
===============

Blocks can be marked as required. They must be overridden at some point, but not necessarily by the direct child template. Required blocks may only contain space and comments, and they cannot be rendered directly.

page.txt
{% block body required %}{% endblock %}
issue.txt
{% extends "page.txt" %}
bug_report.txt
{% extends "issue.txt" %}
{% block body %}Provide steps to demonstrate the bug.{% endblock %}

Rendering page.txt or issue.txt will raise TemplateRuntimeError because they don’t override the body block. Rendering bug_report.txt will succeed because it does override the block.

When combined with scoped, the required modifier must be placed after the scoped modifier. Here are some valid examples:

{% block body scoped %}{% endblock %}
{% block body required %}{% endblock %}
{% block body scoped required %}{% endblock %}

Template Objects
================

extends, include, and import can take a template object instead of the name of a template to load. This could be useful in some advanced situations, since you can use Python code to load a template first and pass it in to render.

if debug_mode:
    layout = env.get_template("debug_layout.html")
else:
    layout = env.get_template("layout.html")

user_detail = env.get_template("user/detail.html")
return user_detail.render(layout=layout)
{% extends layout %}

Note how extends is passed the variable with the template object that was passed to render, instead of a string.